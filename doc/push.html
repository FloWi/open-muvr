<p>In today's post, let's take a explore a sending push notifications from Akka to an iOS application, <em>including</em> all the complexities of setting up the required certificates for push notifications, the iOS code, and packaging the entire solution in a container.</p>
<p>Remember that the application we're building often cannot provide immediate response to the requests it receives other than HTTP 200/202. The server-side code is saying "we heard you, we're working on it." In practical terms in the Lift <a href="https://github.com/eigengo/lift" target="_blank">https://github.com/eigengo/lift</a> application, a <code>PUT</code> to <code>/exercise/:userId/:sessionId</code> with the valid accelerometer data payload results in <code>status = 200, body = {}</code> type of response. It is only when the system classifies the exercise that it may decide to send a push notification to the device telling the user to get on with the exercise. Viz the code in <code>UserExercises</code>:</p>
[code language="scala"]
class UserExercises(notification: ActorRef, exerciseClasssifiers: ActorRef)
  extends PersistentActor with ActorLogging {
  ...

  private def exercising(id: SessionId, sessionProps: SessionProps): 
    Receive = {
    case ExerciseSessionStart(newSessionProps) ⇒
      ...

    case ExerciseDataProcess(`id`, bits) ⇒
      val result = decodeAll(bits, Nil)
      validateData(result).fold(
        { err ⇒ sender() ! \/.left(err)},
        { evt ⇒ exerciseClasssifiers ! Classify(sessionProps, evt); sender() ! \/.right(()) }
      )

    case FullyClassifiedExercise(metadata, confidence, name, intensity) if confidence > confidenceThreshold ⇒
      log.info("FullyClassifiedExercise: exercising -> exercising.")
      persist(ExerciseEvt(id, metadata, Exercise(name, intensity))) { evt ⇒
        tooMuchRestCancellable = Some(context.system.scheduler.scheduleOnce(sessionProps.restDuration, self, TooMuchRest))
        intensity.foreach { i ⇒
          if (i << sessionProps.intendedIntensity) notification ! PushMessage(userId, "Harder!", None, Some("default"), Seq(MobileDestination, WatchDestination))
          if (i >> sessionProps.intendedIntensity) notification ! PushMessage(userId, "Easier!", None, Some("default"), Seq(MobileDestination, WatchDestination))
        }
      }

    case UnclassifiedExercise(_) ⇒
      ...

    case NoExercise(metadata) ⇒
      ...

    case TooMuchRest ⇒
      persist(TooMuchRestEvt(id)) { evt ⇒
        notification ! PushMessage(userId, "Chop chop!", None, Some("default"), Seq(MobileDestination, WatchDestination))
      }
  }

  ...
}
[/code]
<p>Let's dive into the mechanics of the <code>Notification</code> actor, which deals with delivering the notifications to the users' devices.</p>