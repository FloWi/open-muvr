<p>In the previous post, I showed a simple CQRS/ES application. It contained one <code>PersistentActor</code> and one <code>PersistentView</code>. The view was set to auto-update; and so, as the actor persisted messages, the view consumed them. To save reprocessing of <em>all</em> messages upon re-creation of the view, the view periodically created <em>snapshots</em>. However, the example fell way short of actually usable application: it had no API, and it made no distinction between the source of the requests. It was only usable for a single user using its console interface.</p>
<h2>Lift</h2>
<p>So, let's expand on the earlier example, and build a usable application. I'll call it Lift as in <em>do you even </em>lift<em>?</em>" Its smartwatch component sends data over bluetooth LE to a phone, and the phone forwards the data to the application's REST API. The data hits one of the nodes in the cluster, where it is validated, and then analysed.</p>
IMG HERE
<p>In this post, I'll skim over the wearable and mobile code, and focus on the server-side code, starting with the domain. The domain of the application is <em>all users and all their exercises</em>. Allow me to be a bit megalomaniacal, and assume that the application is handling millions of users, each with hundreds of exercises. Clearly, this domain would not fit into a single JVM. It needs to be sharded across the cluster. <!--This is very different than the traditional approach, where one typically uses a database to store the domain, and to provide a contested (!) shared mutable state for all the nodes. Contended access to shared mutable state is the cthulhu of distributed systems.--></p>
<p>Moreover, well-defined supervisor chains and supervisor strategies, together with the event-sourced nature provide the resilience. Underpinning all this is event-driven approach, where the components talk to each other using message-passing. The components themselves use strictly non-blocking code, which aids responsiveness. Event-driven architecture with non-blocking components, appropriate error handling and recovery, together with the ability to shard the domain gives the application the elasticity that my megalomaniacal delusions require.</p>
<h3>API</h3>
<p>The REST API is handled by Spray. The application has only two endpoints: <code>POST /exercise/:id</code> and <code>GET /exercise/:id</code>. The first endpoint submits new data from the smartwatch to be processed, the second endpoint retrieves the exercises, all for user identified by <code>:id</code>. The Scala code follows typical Spray code:</p>
[code language="scala"]
trait ExerciseService extends HttpService with LiftMarshallers {
  import ExerciseProcessor._
  import UserExercises._
  import akka.pattern.ask
  import com.eigengo.pe.timeouts.defaults._

  implicit val _ = actorRefFactory.dispatcher
  def userExerciseProcessor = UserExerciseProcessor.lookup
  def userExercises = UserExercises.lookup

  val exerciseRoute =
    path("exercise" / JavaUUID) { userId ⇒
      post {
        handleWith { bits: BitVector =>
          (userExerciseProcessor ? ExerciseDataCmd(userId, bits)).map(_.toString)
        }
      } ~
      get {
        complete {
          (userExercises ? GetUserExercises(userId)).mapTo[List[ClassifiedExercise]]
        }
      }
    }

}
[/code]
<p>The <code>userExerciseProcessor</code> and <code>userExercises</code> are the actors that process the submitted data, and give the current view of the entire domain, respecitvely. Let's now follow the data through the system. In the POST handler, we ask the <code>UserExerciseProcessor</code> actor to handle the <code>BitVector</code> message. It must combine the new bits with the bits that it may have left over from previous incomplete packets received from the smartwatch, and attempt to decode the new bits. This is all clear, but as you can see, the actor maintains state. It is therefore important that messages from a single user reach the same actor instance. However, the HTTP-level router sends requests to arbitrary node. And so, I must be sure to shard this actor to maintain the appropriate isolation of state. The sharding code needs to be able to look at the message for the actor and decide which actor to send it to. In other words, it needs to be able to—given a message—extract identity of the sharded actor, and extract the name of the sharded actor. The name of the actor shall be the <code>String</code> representation of the <code>userId: UUID</code>. This allows me to take a first stab at the implementation:</p>
[code language="scala"]
class UserExerciseProcessor(userExercises: ActorRef) 
  extends PersistentActor with AtLeastOnceDelivery {

  import com.eigengo.pe.AccelerometerData._
  import com.eigengo.pe.exercise.UserExerciseProcessor._

  private var buffer: BitVector = BitVector.empty

  private def validateData(data: List[AccelerometerData]): 
    \/[String, AccelerometerData] = ???

  override val persistenceId: String = "user-exercise-persistence"

  override def receiveCommand: Receive = {
    case bits: BitVector ⇒
      val (bits2, data) = decodeAll(buffer ++ bits, Nil)
      validateData(data).fold(
        err ⇒ sender() ! \/.left(err),
        evt ⇒ persist(ExerciseDataEvt(???, evt)) { ad ⇒
          buffer = bits2
          sender() ! \/.right('OK)
          userExercises ! ad
        }
      )
  }

}
[/code]
<p>Before I move on to sharding this actor, I should remember to implement the ability to save snapshots and to recover from saved snapshots. This will ensure that the actor can be re-created in the correct state if it ever needs to be restarted.</p>
[code language="scala"]
class UserExerciseProcessor(userExercises: ActorRef) 
  extends PersistentActor with AtLeastOnceDelivery {

  import com.eigengo.pe.AccelerometerData._
  import com.eigengo.pe.exercise.UserExerciseProcessor._

  private var buffer: BitVector = BitVector.empty

  private def validateData(data: List[AccelerometerData]): 
    \/[String, AccelerometerData] = ???

  override val persistenceId: String = "user-exercise-persistence"

  override val receiveRecover: Receive = {
    case SnapshotOffer(_, snapshot: BitVector) ⇒
      buffer = snapshot
  }

  override def receiveCommand: Receive = {
    case ExerciseDataCmd(userId, bits) ⇒
      val (bits2, data) = decodeAll(buffer ++ bits, Nil)
      validateData(data).fold(
        err ⇒ sender() ! \/.left(err),
        evt ⇒ persist(ExerciseDataEvt(userId, evt)) { ad ⇒
          buffer = bits2
          saveSnapshot(buffer)
          sender() ! \/.right('OK)
          userExercises ! ad
        }
      )
  }

}
[/code]
<p>Notice the implementation of <code>receiveRecover</code> and <code>saveSnapshot</code> in the command handler.</p>
<p>Now, as you can see, the actor maintains state. It is therefore important that messages from a single user reach the same actor instance. However, the HTTP-level router sends requests to arbitrary node. And so, I must be sure to shard this actor to maintain the appropriate isolation of state. The sharding code needs to be able to look at the message for the actor and decide which actor to send it to. In other words, it needs to be able to—given a message—extract identity of the sharded actor, and extract the name of the sharded actor. I find it useful to keep the implementations of <code>ShardRegion.IdExtractor</code> and <code>ShardRegion.ShardResolver</code> in the companion object. And so, I have:</p>
[code language="scala"]
object UserExerciseProcessor {
  def props(userExercises: ActorRef) = 
    Props(classOf[UserExerciseProcessor], userExercises)
  val shardName = "user-exercise-processor"
  def lookup(implicit arf: ActorRefFactory) = 
  	actors.shard.lookup(arf, shardName)

  val idExtractor: ShardRegion.IdExtractor = {
    case cmd@ExerciseDataCmd(userId, bits) ⇒ (userId.toString, cmd)
  }

  val shardResolver: ShardRegion.ShardResolver = {
    case ExerciseDataCmd(userId, _) ⇒ userId.toString
  }

  case class ExerciseDataCmd(userId: UUID, bits: BitVector)

  case class ExerciseDataEvt(userId: UUID, data: AccelerometerData)
}
[/code]
<p>One does not create sharded actor using the <code>actorOf</code> call, but using the <code>ClusterSharding(system).start()</code> call. And so, in <code>PeMain</code> I start the <code>UserExerciseProcessor</code> shard using:</p>
[code language="scala"]
ClusterSharding(system).start(
  typeName = UserExerciseProcessor.shardName,
  entryProps = Some(UserExerciseProcessor.props(???)),
  idExtractor = UserExerciseProcessor.idExtractor,
  shardResolver = UserExerciseProcessor.shardResolver)
[/code]
<p>The <code>userExercises</code> parameter passed to the <code>UserExerciseProcessor</code> is a reference to the <code>UserExercises</code> actor, which also happens to be sharded. It receives the <code>AccelerometerData</code> and its job is to classify the data and come up with an exercise from the data.</p>
<h3>UserExercises</h3>
<p>Let's start modeling the domain from its smallest block. The <code>UserExercises</code>, which represents a <code>exercises: List[ClassifiedExercise]</code> for a given <code>userId: UUID</code>. The <code>userId</code> is immutable, but the <code>exercises</code> mutates over time.</p>
[code language="scala"]
class UserExercises extends PersistentActor with ActorLogging {
  private val userId: UUID = ???
  private var exercises = List.empty[ClassifiedExercise]

}
[/code]
<p>Notice that the user-exercises domain is <code>PersistentActor</code>. In other words, there is potentially an actor instance for every user in the system! (Notice potentially: I will explain how to prevent needless user-exercises instances hanging around in memory.) Onwards. The <code>UserExercise</code> actor handles the <code>AccelerometerData</code> with the validated and parsed data the mobile app received from the smartwatch. Upon receiving this message, it will turn the <code>AccelerometerData</code> into <code>ClassifiedExercise</code>. It also handles the <code>GetExercises</code> message, to which it replies with its current state: the <code>exercises</code>. With all this, we can write the <code>receiveCommand</code> function.</p>
[code language="scala"]
class UserExercises extends PersistentActor with ActorLogging {
  import com.eigengo.pe.exercise.ExerciseClassifier._
  import com.eigengo.pe.exercise.UserExercises._

  private val userId: UUID = ???
  private var exercises = List.empty[ClassifiedExercise]

  override def receiveCommand: Receive = {
    // classify the exercise in AccelerometerData
    case evt@AccelerometerData(_, _) ⇒
      persist(evt)(ExerciseClassifiers.lookup !)

    // classification results received
    case e@ClassifiedExercise(confidence, exercise) ⇒
      if (confidence > 0.0) {
        exercises = e :: exercises
        exercise.foreach(e ⇒
          UserPushNotification.lookup ! 
            DefaultMessage(userId, e, Some(1), Some("default")))
      }
      saveSnapshot(exercises)

    // query for exercises
    case GetExercises =>
      sender() ! exercises
  }

}
[/code]
<p>When the <code>AccelerometerData</code> message arrives, the actor persists it, and then pass it on to the exercise classifiers to perform the classification. The result arrives as the <code>ClassifiedExercise</code>, the code that handles the message updates the <code>exercises</code> state, sends notification to the user, and saves the state in the snapshot. Finally, the <code>GetExercises</code> case replies with the current state of the actor to the sender.</p>
