package com.eigengo.lift.exercise.classifiers.svm

import breeze.linalg._
import com.typesafe.config.Config
import org.parboiled2._
import scala.io.Source
import scalaz.{DisjunctionFunctions, \/, -\/}

private[svm] trait ParserUtils {
  this: Parser =>

  import CharPredicate.{Alpha, AlphaNum, Digit, Digit19}

  implicit def whitespace(s: String): Rule0 = rule {
    str(s) ~ zeroOrMore(anyOf(" \t"))
  }

  def NL: Rule0 = rule { optional('\r') | '\n' }

  def Decimal: Rule1[Double] = rule {
    capture(optional(anyOf("+-")) ~ oneOrMore(Digit) ~ optional('.' ~ oneOrMore(Digit)) ~ optional(ignoreCase('e') ~ optional(anyOf("+-")) ~ oneOrMore(Digit))) ~> (_.toDouble)
  }
  
  def Integer: Rule1[Int] = rule {
    capture(optional(anyOf("+-")) ~ (Digit19 ~ zeroOrMore(Digit) | Digit)) ~> (_.toInt)
  }
  
  def Identifier: Rule1[String] = rule {
    capture((Alpha | '_') ~ zeroOrMore(AlphaNum | '_'))
  }

}

/**
 * Provides a parser suitable for reading libsvm files generated by R. We bake in the assumption that we are parsing a
 * libsvm model of type C-classification and that uses a radial basis function kernel.
 */
private[svm] class LibSVMParser(val input: ParserInput) extends Parser with ParserUtils {

  import CharPredicate.AlphaNum
  import SVMClassifier._

  case class SupportVector(label: Double, values: Seq[Double])

  def Key: Rule1[String] = capture(oneOrMore(AlphaNum | '_'))

  def Value = Decimal | Integer | Identifier

  def Index = ???

  def Label = ???

  // NOTE: we intentionally ignore fact that labels may (in general) be comma separated
  def SupportVectorEntry: Rule1[SupportVector] = rule {
    Label ~ zeroOrMore(Index ~ ':' ~ Value ~> ???) ~> SupportVector
  }

  def parse: Rule1[SVMModel] = rule {
    zeroOrMore(Key ~ Value).separatedBy(NL) ~
    str("SV") ~ NL ~
    zeroOrMore(SupportVectorEntry).separatedBy(NL) ~
    EOI ~> {
      case (kv, sv) =>
        // Sanity checking of the parsed libsvm model description - any deviation is a parse error!
        assert(kv.contains("svm_type") && kv("svm_type") == "c_svc")
        assert(kv.contains("kernel_type") && kv("kernel_type") == "rbf")
        assert(kv.contains("nr_class") && kv("nr_class") == 2)
        assert(kv.contains("total_sv") && kv("total_sv") == sv.length)
        assert(kv.contains("gamma"))
        assert(kv.contains("rho"))
        assert(kv.contains("probA"))
        assert(kv.contains("probB"))
        assert(sv.nonEmpty)
        assert(sv.forall(_.length == sv.head.length))

        SVMModel(
          nSV = kv("total_sv"),
          SV = DenseMatrix.tabulate(kv("total_sv"), sv.head.length) { case (r, c) => sv(r)(c) },
          gamma = kv("gamma"),
          coefs = DenseVector(sv.map(_.label): _*),
          rho = kv("rho"),
          probA = kv("probA"),
          probB = kv("probB"),
          scaled = None // Will be defined by the calling parsing context
        )
    }
  }

}

/**
 * Provides a parser suitable for reading scale files generated by R.
 */
private[svm] class SVMScaleParser(val input: ParserInput) extends Parser with ParserUtils {

  import SVMClassifier._

  case class ScaledData(x: Double, center: Double)

  def parse: Rule1[SVMScale] = rule {
    zeroOrMore(Decimal ~ Decimal ~> ScaledData).separatedBy(NL) ~ optional(NL) ~ EOI ~> ( data =>
      SVMScale(DenseVector(data.map(_.x): _*), DenseVector(data.map(_.center): _*))
    )
  }

}

/**
 * Parses R generated libSVM and scale files to build an SVM model. R files making up our model are assumed to be on the
 * classes resource path.
 *
 * @param name name of libSVM model we are to parse
 */
class SVMModelParser(name: String)(implicit config: Config) extends DisjunctionFunctions {

  import Parser.DeliveryScheme.Either
  import SVMClassifier._

  val modelPath = config.getString("classification.model.path")
  val modelName = config.getString(s"classification.gesture.$name.model")

  def model: \/[String, SVMModel] = {
    Option(getClass.getResource(s"$modelPath$modelName.libsvm")).map { libSVMFile =>
      Option(getClass.getResource(s"$modelPath$modelName.scale")).map { scaledFile =>
        for {
          libsvm <- fromEither(new LibSVMParser(Source.fromURL(libSVMFile, "UTF-8").mkString).parse.run()).leftMap(_.getMessage)
          scale  <- fromEither(new SVMScaleParser(Source.fromURL(scaledFile, "UTF-8").mkString).parse.run()).leftMap(_.getMessage)
        } yield libsvm.copy(scaled = Some(scale))
      }.getOrElse(-\/(s"$modelPath$modelName.scale does not exist on the class path!"))
    }.getOrElse(-\/(s"$modelPath$modelName.libsvm does not exist on the class path!"))
  }

}
